# 实验六 进程间通信



## 实验目的

了解 Linux系统的通信机制，管道、消息队列、信号量的创建与使用、共享 内存。



## 实验原理

### 1. 进程通信概述

#### 1.1 进程通信简介

进程间通信(Inter-Process Communication)是指多个进程之间相互通信，交换信息的方法

Linux环境下，进程的地址空间相互独立，任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程间不能互相访问，要交换数据必须通过内核，在内核中开辟一块缓存区，进程1把数据从用户空间拷贝到内存缓冲区，进程2再从内存缓冲区中把数据读走，内核提供的这种机制称为进程间通信（IPC）

#### 1.2 进程通信目的

+ 传输数据
+ 共享数据/资源
+ 通知事件
+ 进程控制

#### 1.3 进程通信方式

+ 管道/FIFO
+ 消息队列
+ 共享内存
+ 信号量
+ 信号
+ Socket



### 2. 进程通信的6方式

#### 2.1 Pipe/FIFO

**pipe**

> 管道和普通fork来读写文件的最大区别是，管道再读完数据后，管道里的内容就没了，而普通的不会

**相关函数**

```c
#include <fcntl.h>              
#include <unistd.h>

int pipe(int fd[2]);
```

**pipe.c**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#define BUF_SIZE 1024

int main(){
        int fd[1],pid,n,i,status;
        char buf[BUF_SIZE];
        char *rd="message read from the pipe: ";
        pipe(fd);

        //puts(buf);
        if( (pid = fork())< 0 ){
                perror("fork failed\n");

        }else if( pid == 0 ){     //now in child process, read message from the pipe
                close(fd[1]);
                while((n = read(fd[0],buf,BUF_SIZE)) > 0 ){
                        write(STDOUT_FILENO,rd,strlen(rd));
                        write(STDOUT_FILENO,buf,n);
                }
                close(fd[0]);
                exit(0);
        }else{                    //now in parent process, write message to the pipe
                close(fd[0]);
                while((n = read(STDIN_FILENO,buf,BUF_SIZE)) > 0){
                        write(fd[1],buf,n);
                }
                close(fd[1]);

        }
        return 0;
}
```

![image-20220604113944547](https://tva1.sinaimg.cn/large/e6c9d24ely1h2w27iig77j21f0092jt6.jpg)



#### 2.2 消息队列



#### 2.3 共享内存



#### 2.4 信号量



#### 2.5 信号



#### 2.6 Socket



## 实验作业

