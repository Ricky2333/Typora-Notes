# 实验五 进程与线程同步



## 实验目的

加深对进程概念的理解，认识并发执行的实质，分析进程征用资源的现象， 学习进程、线程互斥的方法。



## 实验原理

### 1.线程的基本概念

+ 线程是一条执行路径，是计算机中 **独立运行的最小单位**，它是进程的一个执行流，是 **CPU调度和分派的基本单位**
+ 一个进程可以由多个线程组成，线程间 **共享进程的所有资源**，但每个线程又有**各自的堆栈和局部变量**
  + 对于**单核CPU**而言：多线程就是一个CPU在来回的切换，在交替执行。
  + 对于**多核CPU**而言：多线程就是同时有多条执行路径在同时(并行)执行，每个核执行一个线程，多个核就有可能是一块同时执行的。

+ 一个正在运行的软件(如百度网盘)就是一个进程，一个进程可以同时运行多个任务( 百度网盘可以同时下载多个文件，每个下载任务就是一个线程)，可以简单的认为进程是线程的集合。

[线程介绍的相关博客—CSDN](https://blog.csdn.net/weixin_43884234/article/details/114954221?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165449714016782350981806%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165449714016782350981806&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-114954221-null-null.142^v11^pc_search_result_control_group,157^v13^new_style&utm_term=%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4187)



### 2.进程与线程的关系

一个操作系统中可以有多个进程,一个进程中可以包含一个线程(单线程程序),也可以包含多个线程(多线程程序)

![进程与线程的关系](https://img-blog.csdnimg.cn/20210317231249749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70)

线程相对于进程的**优点**

+ 在一个程序中需要并发处理多个任务时（例如需要并发监控2个不同的fifo），以多线程的方式编程更符合人的思维
+ 多线程编程使得多个任务间的 **通信更加直观和方便**（例如可以使用共享的全局变量）
+ 多线程的 **切换开销** 更小



### 3.线程的相关函数

#### 3.1 pthread_self()

##### pthread_self()功能

>  **获取当前线程的ID**，类似于用 **`getpid()`**获取当前进程PID

##### pthread_self()原型

```C
#include <pthread.h>

pthread_t pthread_self(void);
```

##### pthread_self()返回值

> 返回当前线程的ID

##### pthread_self()参数解释

> 该函数无传入参数

##### pthread_self()编程实例

```C
pthread_t tid          //可以理解为 typedef unsigned long int pthread_t
tid = pthread_self();  //获取当前线程ID
printf("Current thread's ID is %lu\n", tid);
```



#### 3.2 pthread_create()

##### pthread_create()功能

>  **创建一个新的线程**，类似于用 **`fork()`**创建子进程

##### pthread_create()原型

```C
#include <pthread.h>

int pthread_create(
	pthread_t *thread, 
  const pthread_attr_t *attr,
  void *(*start_routine) (void *),
  void *arg 
);
```

##### pthread_create()返回值

> 如果操作成功，**返回0**；如果操作失败，**返回错误值**

##### pthread_create()参数解释

> **`pthread_t *thread`**  表示新创建的线程ID **指向的内存单元**

> **`const pthread_attr_t *attr`** 表示线程属性，**通常为 NULL**

> **`void *(*start_routine) (void *)`** 函数指针，**新创建的线程将从start_routine函数的地址开始运行**

> **`void *arg`**  若start_routine函数需要参数，将参数放入结构中并将地址作为arg传入，**通常为NULL**

##### pthread_create()编程实例

```C
void * thread1(void *arg){         //定义thread1函数指针，作为start_routine
        pthread_t thid=pthread_self();
        printf("Current thread's ID is %lu\n", thid);
}

int main(){
	pthread_t tid;   

	if( (tid = pthread_create(&tid,NULL,thread1,NULL) != 0){  //创建一个新的进程
  	perror("thread create failed");
  	exit(1);
	}
     
}
```



#### 3.3 pthread_exit()

##### pthread_exit()功能

>  **结束当前线程**

##### pthread_exit()原型

```C
#include <pthread.h>

void pthread_exit(void *retval);
```

##### pthread_exit()返回值

> 该函数无返回值

##### pthread_exit()参数解释

> **`void *retval`** 表示线程退出状态，**通常为NULL**

##### pthread_exit()编程实例

```C
void * thread1(void *arg){      
  			pthread_exit(NULL);   //退出当前线程
}
```

##### exit() & pthread_exit()

+ 在任何线程里使用 **`exit()`**，都会导致进程终止，使得 **其他线程还未完成当前任务，就被终止**

+ 因此，在多线程环境中，应 **少用或不使用 `exit()`**，而是用 **`pthread_exit()`**，将单个线程



#### 3.4 pthread_cancel()

##### pthread_cancel()功能

>  **杀死一个线程**，类似于用 **`kill命令`** 杀死进程

##### pthread_cancle()原型

```C
#include <pthread.h>

int pthread_cancel(pthread_t thread);
```

##### pthread_cancel()返回值

> 如果操作成功，**返回0**；如果操作失败，**返回错误值**

##### pthread_cancel()参数解释

>  **`pthread_t thread`**  表示想要杀死的子线程的ID

##### pthread_cancel()编程实例

```C
pthread_cancel(tid1)  //杀死线程ID为tid1的线程
```



#### 3.5 pthread_join()

##### pthread_join()功能

>  **阻塞主线程，获取子线程退出状态**，类似于用 **`waitpid()`**阻塞父进程并且获得子进程退出状态

##### pthread_join()原型

```C
#include <pthread.h>

int pthread_join(pthread_t thread, void **retval);
```

##### pthread_join()返回值

> 如果操作成功，**返回0**；如果操作失败，**返回错误值**

##### pthread_join()参数解释

>  **`pthread_t thread`**  表示想要获取退出状态的子线程的ID

> **`void **retval`** 表示**指向** 指定线程的退出码的 **二级指针** （类似于 **`wait(&status)`**中的 **`&status`** )

##### pthread_join()编程实例

```C
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void* thread_run(void* arg)
{
        sleep(3);
        printf("thread %lu is running\n",pthread_self());
}

int main()
{
    pthread_t tid;
    pthread_create(&tid, NULL, thread_run,NULL);

    pthread_join(tid,NULL);  //主线程"main"会阻塞，直到tid线程执行完毕
        printf("main thread exit\n");
    return 0;
}
```

![image-20220606160741318](https://tva1.sinaimg.cn/large/e6c9d24ely1h2yl6vnly9j21f2044gmo.jpg)





## 实验作业

### createthread.c实践

#### 源代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
int * thread(void * arg) {
        pthread_t newthid;
        newthid = pthread_self();
        printf("this is a new thread, thread ID = %lu\n", newthid);
        return NULL;
}

int main(void) {
        pthread_t thid;
        printf("main thread ,ID is %lu\n",pthread_self());
        if(pthread_create(&thid, NULL, (void *)thread, NULL) != 0) {
                printf("thread creation failed\n");
                exit(1);
        }
        sleep(1); //在多线程环境中，父进程终止，所有子线程被迫终止
        exit(0);
}
```

#### 问题描述

> 编译并运行该程序，查看运行结果

#### 程序运行截图

![image-20220606121417721](https://tva1.sinaimg.cn/large/e6c9d24ely1h2yeg14cjhj21wm05iju7.jpg)

#### 结果分析

+ 该程序首先输出了main thread的线程ID，然后创建了一个子线程，并且输出了该子线程的ID



### oncerun.c实践

#### 源代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
pthread_once_t once = PTHREAD_ONCE_INIT;
void run(void){
        printf("Fuction run is running in thread %lu\n",pthread_self());
}
void * thread1(void *arg){
        pthread_t thid=pthread_self();
        printf("Current thread's ID is %lu\n", thid);
        pthread_once(&once,run);
        printf("thread1 ends\n");
}
void * thread2(void *arg){
        pthread_t thid=pthread_self();
        printf("Current thread's ID is %lu\n", thid);
        pthread_once(&once, run);
        printf("thread2 ends\n");
}
int main(void){
        pthread_t thid1,thid2;

        pthread_create(&thid1,NULL,thread1,NULL);
        pthread_create(&thid2,NULL, thread2,NULL);
        sleep(3);

        printf("main thread exit! \n");
        exit(0);
}
```

#### 问题描述

> 请编译并运行，通过结果分析线程的执行情况

#### 程序运行截图

![image-20220606121649394](https://tva1.sinaimg.cn/large/e6c9d24ely1h2yeinr0ikj21qe0aqdjt.jpg)

#### 结果分析

+ 该程序首先输出了main thread的线程ID，然后创建了两个子线程thread1和thread2，分别输出了这两个子线程的ID
+ 同时，在两个子线程中，均调用了run函数。但是由于pthread_once函数的存在，使得thread2中的调用未生效，在thread2中不会执行run函数的内容



### condition.c实践

#### 源代码

```c
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;

void *thread1(void *arg){
        pthread_cleanup_push (pthread_mutex_unlock, &mutex);
        while(1) {
                printf ("thread1 is running\n");
                pthread_mutex_lock (&mutex);
                pthread_cond_wait (&cond, &mutex);
                printf ("thread1 applied the condition\n");
                pthread_mutex_unlock (&mutex);
                sleep (4);
        }
        pthread_cleanup_pop (0);
}

void *thread2(void *arg){
        while(1) {
                printf ("thread2 is running\n");
                pthread_mutex_lock (&mutex);
                pthread_cond_wait (&cond, &mutex);
                printf ("thread2 applied the condition\n");
                pthread_mutex_unlock (&mutex);
                sleep (1);
        }
}

int main(void){
        pthread_t tid1, tid2;
        printf ("condition variable study! \n");
        pthread_mutex_init (&mutex, NULL);
        pthread_cond_init (&cond, NULL);
  
        pthread_create (&tid1, NULL, (void *) thread1, NULL);
        pthread_create (&tid2, NULL, (void *) thread2, NULL);

        do {
                pthread_cond_signal (&cond);
        } while (1);

        sleep (50);
        pthread_exit (0);
}
```

#### 问题描述

> 编译执行程序,结果是什么？请分析thread1和thread2同步运行的情况

#### 程序运行截图

![image-20220606123029791](https://tva1.sinaimg.cn/large/e6c9d24ely1h2yewvx297j21cw08qdhk.jpg)

#### 结果分析

+ 



### 编程练习1

#### 问题描述

> 编写一个多线程程序：要求主线程创建 3个子线程， 3个子线程在执行时都修改一个它们的共享变量，观察共享变量的值，看看可以得出什么结论

#### 源代码

```c

```

#### 程序运行截图

#### 结果分析



### 编程练习2

#### 问题描述

> 编写一个多进程多线程的程序：要求创建4个子进程，每个子进程都分别创建两个线程，进程和线程的功能不做要求，可以只提供简单的打印语句。

#### 源代码

```c

```

#### 程序运行截图



#### 结果分析





